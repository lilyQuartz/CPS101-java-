import java.util.*;
//************************************************
// File:       Assignment-2-1
// Author:     India Heisz
// Date:       25 January 2016
// Course:     CPS 101
//
// PROBLEM STATEMENT: 
// Complete the solution to the iterative maze solver so that your solution marks the successful path.
// Modify the program so that it uses jsjf.LinkedStack implementation of StackADT.
//
// Develop a new dynamic implementation of StackADT using the LinearNode class. The new class should be called EndLinkedStack .
// This implementation contains only the top instance variable. There is no count instance variable.
// Also, the top of the stack should be at the end of the linked list.
// Create a package "testing" that will contain  JUnit tests of your EndLinkedStack implementation.
// Demonstrate that your EndLinkedStack class works by using it in PROBLEM 1.
//
// NOTE: This code is heavily based on a program by Lewis and Chase
//
// INPUT: ?????******
// 
// OUTPUT: ?????******
//
//*************************************************

public class MazeSolver
{
    private Maze maze;
    
    public MazeSolver(Maze maze)
    {
        this.maze = maze;
    }
    
    /**
     * Attempts to recursively traverse the maze. Inserts special
     * characters indicating locations that have been TRIED and that
     * eventually become part of the solution PATH.
     *
     * @param row row index of current location
     * @param column column index of current location
     * @return true if the maze has been solved
     */
    public boolean traverse()
    {
        boolean done = false;
        int row, column;
        Position pos = new Position();
        Deque<Position> stack = new LinkedList<Position>();
        stack.push(pos);
        
        while (!(done) && !stack.isEmpty())
        {
            pos = stack.pop();
            maze.tryPosition(pos.getx(),pos.gety());  // this cell has been tried
            if (pos.getx() == maze.getRows()-1 && pos.gety() == maze.getColumns()-1)
                done = true;  // the maze is solved
            else
            {
                push_new_pos(pos.getx() - 1,pos.gety(), stack); 
                push_new_pos(pos.getx() + 1,pos.gety(), stack);
                push_new_pos(pos.getx(),pos.gety() - 1, stack);
                push_new_pos(pos.getx(),pos.gety() + 1, stack); 
            }
        }
        
        return done;
    }
    
    /**
     * Push a new attempted move onto the stack
     * @param x represents x coordinate
     * @param y represents y coordinate
     * @param stack the working stack of moves within the grid
     * @return stack of moves within the grid
     */
    private void push_new_pos(int x, int y, 
                                         Deque<Position> stack)
    {
        Position npos = new Position();
        npos.setx(x);
        npos.sety(y);
        if (maze.validPosition(x,y))
            stack.push(npos);
    }
    
}
